<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Killian‚Äôs Spin the Wheel</title>

  <!-- If you already have manifest.webmanifest + sw.js in the repo, keep these -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#171525">

  <style>
    :root{
      --bg1:#0b0b18;
      --bg2:#1b1233;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.06);
      --stroke:rgba(255,255,255,.12);
      --stroke2:rgba(255,255,255,.18);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --shadow: 0 20px 80px rgba(0,0,0,.45);
      --round: 22px;

      --wheelSize: 560px; /* JS updates this responsively */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% 10%, rgba(255,120,220,.25), transparent 60%),
        radial-gradient(900px 700px at 85% 10%, rgba(80,220,255,.18), transparent 65%),
        radial-gradient(1100px 900px at 30% 85%, rgba(120,255,160,.12), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
    }

    /* subtle stars */
    .stars{
      position:fixed; inset:0;
      pointer-events:none;
      background-image:
        radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(1px 1px at 70% 35%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(2px 2px at 85% 65%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 55% 15%, rgba(255,255,255,.14) 45%, transparent 46%),
        radial-gradient(1px 1px at 15% 55%, rgba(255,255,255,.14) 45%, transparent 46%);
      opacity:.7;
      filter: blur(.2px);
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:24px 16px 36px;
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      margin-bottom:18px;
    }
    .title{
      display:flex; gap:12px; align-items:flex-start;
    }
    .title h1{
      margin:0;
      font-size: clamp(28px, 3.6vw, 44px);
      line-height:1.05;
      letter-spacing:.3px;
    }
    .subtitle{
      margin-top:8px;
      color:var(--muted);
      font-size: 16px;
    }
    .pill{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding:10px 14px;
      border-radius:999px;
      background: rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
      font-weight:650;
      font-size:13px;
      color: rgba(255,255,255,.82);
      margin-left:10px;
    }

    .toggles{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 14px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      user-select:none;
    }
    .toggle input{width:18px;height:18px}
    .toggle span{color:rgba(255,255,255,.86); font-weight:650}

    .grid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
      align-items:start;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border:1px solid rgba(255,255,255,.12);
      border-radius: var(--round);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardPad{ padding:16px; }

    /* LEFT: wheel area */
    .wheelTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      padding:18px 18px 0;
    }
    .bigBtn{
      border:0;
      cursor:pointer;
      padding:16px 18px;
      border-radius: 18px;
      font-weight:900;
      letter-spacing:.4px;
      font-size:18px;
      color:rgba(0,0,0,.82);
      background: linear-gradient(90deg, #74ffca, #ffd86a, #ff62d0);
      box-shadow: 0 16px 60px rgba(255,105,210,.18);
      transition: transform .08s ease;
    }
    .bigBtn:active{transform: translateY(1px) scale(.99)}
    .bigBtn[disabled]{opacity:.6; cursor:not-allowed}

    .smallBtns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      margin-left:auto;
    }
    .chipBtn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.86);
      border-radius: 999px;
      padding:10px 14px;
      font-weight:800;
      cursor:pointer;
      box-shadow: 0 12px 45px rgba(0,0,0,.22);
    }

    .wheelStage{
      position:relative;
      display:flex;
      justify-content:center;
      align-items:center;
      padding:18px 14px 22px;
      min-height: 360px;
    }

    /* pointer */
    .pointer{
      position:absolute;
      top:10px;
      left:50%;
      transform: translateX(-50%);
      width:0;height:0;
      border-left:18px solid transparent;
      border-right:18px solid transparent;
      border-bottom:28px solid rgba(255,255,255,.92);
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      z-index: 6;
    }
    .pointer::after{
      content:"";
      position:absolute;
      left:-10px;
      top:18px;
      width:20px;height:20px;
      background: rgba(255,255,255,.92);
      border-radius: 50%;
      box-shadow: 0 10px 22px rgba(0,0,0,.35);
    }

    /* wheel + lights lock to same box */
    .wheelBox{
      position:relative;
      width: var(--wheelSize);
      max-width: 92vw;
      aspect-ratio: 1 / 1;
      display:grid;
      place-items:center;
    }

    canvas#wheel{
      width:100%;
      height:100%;
      display:block;
      border-radius:50%;
      filter: drop-shadow(0 18px 70px rgba(0,0,0,.55));
      z-index: 2;
    }

    /* light ring */
    .lights{
      position:absolute;
      inset:-9%;
      border-radius:50%;
      z-index: 1;
      pointer-events:none;
    }
    .light{
      position:absolute;
      width:14px; height:14px;
      border-radius:50%;
      background: rgba(255,255,255,.85);
      box-shadow: 0 0 18px rgba(255,255,255,.35);
      opacity:.9;
      transition: transform .12s linear;
    }
    .lights.off{display:none}
    .light.dim{opacity:.55; filter:saturate(.9)}
    .light.bright{opacity:1}

    /* result modal */
    .overlay{
      position:fixed; inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background: rgba(0,0,0,.55);
      z-index: 50;
      padding:16px;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(560px, 95vw);
      border-radius: 24px;
      background: linear-gradient(180deg, rgba(35,28,60,.96), rgba(20,16,34,.96));
      border:1px solid rgba(255,255,255,.14);
      box-shadow: 0 30px 120px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .modalHead{
      padding:16px 18px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .modalHead b{font-size:16px}
    .closeX{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:rgba(255,255,255,.9);
      border-radius: 12px;
      padding:8px 10px;
      cursor:pointer;
      font-weight:900;
    }
    .modalBody{
      padding:18px;
      text-align:center;
    }
    .resultBig{
      font-size: clamp(26px, 3vw, 34px);
      font-weight:1000;
      letter-spacing:.2px;
      margin: 6px 0 10px;
    }
    .resultTag{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding:10px 14px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:900;
      margin-bottom:10px;
    }
    .hint{color:var(--muted); font-size:14px; margin:0}

    /* RIGHT: items editor */
    .panelHead{
      padding:16px 16px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .panelHead h2{margin:0; font-size:18px; letter-spacing:.3px}
    .panelHead p{margin:8px 0 0; color:var(--muted); font-size:14px}

    .list{
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height: 74vh;
      overflow:auto;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:center;
      padding:12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
    }
    .row input{
      width:100%;
      padding:12px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(15,12,30,.35);
      color:rgba(255,255,255,.92);
      outline:none;
      font-weight:650;
    }
    .typePill{
      cursor:pointer;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:950;
      min-width: 110px;
      text-align:center;
      user-select:none;
    }
    .del{
      cursor:pointer;
      width:42px;height:42px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      font-weight:1000;
    }
    .panelFoot{
      display:flex;
      gap:10px;
      padding:14px;
      border-top:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .btn{
      flex:1;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      border-radius: 16px;
      padding:12px 14px;
      font-weight:950;
      cursor:pointer;
    }
    .btn.primary{
      border:0;
      color: rgba(0,0,0,.82);
      background: linear-gradient(90deg, #74ffca, #ffd86a, #ff62d0);
    }

    /* MOBILE */
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
      .list{max-height:none}
      .wheelStage{min-height: 320px}
      .smallBtns{justify-content:flex-start; margin-left:0}
    }
    @media (max-width: 420px){
      .typePill{min-width: 92px}
      .chipBtn{padding:9px 12px}
      .bigBtn{font-size:16px}
    }
  </style>
</head>

<body>
  <div class="stars"></div>

  <div class="wrap">
    <header>
      <div class="title">
        <div>
          <h1>Killian‚Äôs<br>Spin the Wheel <span class="pill">offline ‚Ä¢ single file ‚Ä¢ parent-approved</span></h1>
          <div class="subtitle">Spin for a reward‚Ä¶ unless it lands on the üíÄ skull!</div>
        </div>
      </div>

      <div class="toggles">
        <label class="toggle">
          <input id="soundToggle" type="checkbox" checked />
          <span>üîä Sound</span>
        </label>
        <label class="toggle">
          <input id="confettiToggle" type="checkbox" checked />
          <span>üéâ Confetti</span>
        </label>
        <label class="toggle">
          <input id="lightsToggle" type="checkbox" checked />
          <span>üí° Lights</span>
        </label>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <section class="card">
        <div class="wheelTop">
          <button id="spinBtn" class="bigBtn">SPIN THE WHEEL</button>

          <div class="smallBtns">
            <button class="chipBtn" id="testWin">Test WIN üéÅ</button>
            <button class="chipBtn" id="testSkull">Test SKULL üíÄ</button>
            <button class="chipBtn" id="testMystery">Test MYSTERY ‚ùì</button>
          </div>
        </div>

        <div class="wheelStage">
          <div class="pointer"></div>

          <div class="wheelBox" id="wheelBox">
            <div class="lights" id="lights"></div>
            <canvas id="wheel" width="900" height="900"></canvas>
          </div>
        </div>
      </section>

      <!-- RIGHT -->
      <aside class="card">
        <div class="panelHead">
          <h2>WHEEL ITEMS</h2>
          <p>Tap the pill to switch between <b>GOOD</b>, <b>SKULL</b>, and <b>MYSTERY</b>. Then hit <b>Update Wheel</b>.</p>
        </div>

        <div class="list" id="list"></div>

        <div class="panelFoot">
          <button class="btn" id="addRow">+ Add item</button>
          <button class="btn primary" id="updateWheel">Update Wheel</button>
        </div>
      </aside>
    </div>
  </div>

  <!-- RESULT -->
  <div class="overlay" id="overlay">
    <div class="modal">
      <div class="modalHead">
        <b id="modalTitle">Result</b>
        <button class="closeX" id="closeModal">‚úï</button>
      </div>
      <div class="modalBody">
        <div class="resultTag" id="resultTag">üéÅ GOOD</div>
        <div class="resultBig" id="resultText">Chocolate ice cream</div>
        <p class="hint" id="resultHint">Spin again any time!</p>
      </div>
    </div>
  </div>

  <script>
    // --- Simple PWA register (only if sw.js exists) ---
    (function(){
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./sw.js').catch(()=>{});
        });
      }
    })();

    // ---- Defaults ----
    const DEFAULT_ITEMS = [
      { text: "Chocolate ice cream", type:"GOOD" },
      { text: "Play Xbox for 20 minutes", type:"GOOD" },
      { text: "Later bedtime", type:"GOOD" },
      { text: "Dance party üéµ", type:"GOOD" },
      { text: "Minecraft skins", type:"GOOD" },
      { text: "MYSTERY Prize (Parents‚Ä¶)", type:"MYSTERY" },
      { text: "SKULL: Clean toys üß∏", type:"SKULL" },
      { text: "SKULL: Take a shower üöø", type:"SKULL" },
    ];

    const TYPE_ORDER = ["GOOD","SKULL","MYSTERY"];
    const TYPE_BADGE = {
      GOOD:   { label:"üéÅ GOOD",   mood:"good" },
      SKULL:  { label:"üíÄ SKULL",  mood:"skull" },
      MYSTERY:{ label:"‚ùì MYSTERY",mood:"mystery" },
    };

    // slice colors
    const PALETTE = [
      ["#54ffd0","#2fe2ff"],
      ["#ffd86a","#ff7fd4"],
      ["#7dff7f","#2fe2ff"],
      ["#ff92d7","#a18cff"],
      ["#ff6d7a","#ffcc5a"],
      ["#6cffc9","#62ffd1"],
      ["#b65cff","#ff62d0"],
      ["#4aa6ff","#62ffd1"],
      ["#ff7f50","#ff62d0"],
      ["#75ffca","#ffd86a"],
    ];

    // ---- State ----
    const storageKey = "killians_wheel_items_v2";
    let items = loadItems();
    let spinning = false;

    // ---- Elements ----
    const canvas = document.getElementById('wheel');
    const ctx = canvas.getContext('2d');
    const wheelBox = document.getElementById('wheelBox');

    const listEl = document.getElementById('list');
    const spinBtn = document.getElementById('spinBtn');
    const overlay = document.getElementById('overlay');
    const closeModal = document.getElementById('closeModal');
    const resultText = document.getElementById('resultText');
    const resultTag = document.getElementById('resultTag');
    const resultHint = document.getElementById('resultHint');

    const soundToggle = document.getElementById('soundToggle');
    const confettiToggle = document.getElementById('confettiToggle');
    const lightsToggle = document.getElementById('lightsToggle');

    const lightsEl = document.getElementById('lights');

    // ---- Build list UI ----
    function buildList(){
      listEl.innerHTML = "";
      items.forEach((it, idx) => {
        const row = document.createElement('div');
        row.className = "row";

        const input = document.createElement('input');
        input.value = it.text;
        input.placeholder = "Item text‚Ä¶";
        input.addEventListener('input', () => {
          items[idx].text = input.value;
          saveItems();
          draw();
        });

        const pill = document.createElement('div');
        pill.className = "typePill";
        pill.textContent = it.type === "GOOD" ? "üéÅ GOOD" : it.type === "SKULL" ? "üíÄ SKULL" : "‚ùì MYSTERY";
        pill.addEventListener('click', () => {
          const i = TYPE_ORDER.indexOf(items[idx].type);
          items[idx].type = TYPE_ORDER[(i+1)%TYPE_ORDER.length];
          buildList();
          saveItems();
          draw();
        });

        const del = document.createElement('button');
        del.className = "del";
        del.textContent = "‚úï";
        del.addEventListener('click', () => {
          items.splice(idx,1);
          if (items.length < 2) {
            items.push({text:"Another prize", type:"GOOD"});
          }
          buildList();
          saveItems();
          draw();
          buildLights();
        });

        row.appendChild(input);
        row.appendChild(pill);
        row.appendChild(del);
        listEl.appendChild(row);
      });
    }

    document.getElementById('addRow').addEventListener('click', () => {
      items.push({text:"New item", type:"GOOD"});
      buildList();
      saveItems();
      draw();
      buildLights();
    });

    document.getElementById('updateWheel').addEventListener('click', () => {
      saveItems();
      draw();
      buildLights();
      pulseButton(document.getElementById('updateWheel'));
    });

    // ---- Load/Save ----
    function loadItems(){
      try{
        const raw = localStorage.getItem(storageKey);
        if(!raw) return structuredClone(DEFAULT_ITEMS);
        const parsed = JSON.parse(raw);
        if(!Array.isArray(parsed) || parsed.length < 2) return structuredClone(DEFAULT_ITEMS);
        return parsed.map(x => ({
          text: String(x.text ?? "").slice(0, 120),
          type: TYPE_ORDER.includes(x.type) ? x.type : "GOOD"
        }));
      }catch{
        return structuredClone(DEFAULT_ITEMS);
      }
    }
    function saveItems(){
      localStorage.setItem(storageKey, JSON.stringify(items));
    }

    // ---- Responsive wheel sizing ----
    function updateWheelSize(){
      const box = wheelBox.getBoundingClientRect();
      const size = Math.max(260, Math.min(box.width, window.innerWidth * 0.92));
      document.documentElement.style.setProperty("--wheelSize", size + "px");

      // keep canvas crisp
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(900 * dpr);
      canvas.height = Math.floor(900 * dpr);
      ctx.setTransform(dpr,0,0,dpr,0,0); // draw in CSS pixels
      draw();
      buildLights();
    }

    window.addEventListener('resize', () => {
      updateWheelSize();
    });

    // ---- Draw wheel (THIS FIXES YOUR TEXT ISSUE) ----
    function draw(){
      const w = 900, h = 900;
      ctx.clearRect(0,0,w,h);

      const cx = w/2, cy = h/2;
      const R = 410;                 // outer radius of wheel
      const innerR = 88;             // center hub
      const rimW = 34;

      // rim shadow ring (NO giant grey overlay anymore)
      ctx.save();
      ctx.translate(cx,cy);
      ctx.beginPath();
      ctx.arc(0,0,R+rimW,0,Math.PI*2);
      ctx.arc(0,0,R-rimW,0,Math.PI*2,true);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.fill();

      // rim highlight
      ctx.beginPath();
      ctx.arc(0,0,R+rimW-6,0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();

      const n = Math.max(2, items.length);
      const step = (Math.PI*2)/n;
      const startAngle = -Math.PI/2; // pointer at top

      // slices
      for(let i=0;i<n;i++){
        const a0 = startAngle + i*step;
        const a1 = a0 + step;

        const [c1,c2] = PALETTE[i % PALETTE.length];

        // slice fill
        const grad = ctx.createRadialGradient(cx,cy,innerR, cx,cy,R);
        grad.addColorStop(0, "rgba(255,255,255,.10)");
        grad.addColorStop(.22, c1);
        grad.addColorStop(1, c2);

        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,R,a0,a1);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        // slice border
        ctx.strokeStyle = "rgba(0,0,0,.35)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // hub
      ctx.save();
      ctx.translate(cx,cy);

      // inner glow rings
      for(let k=0;k<4;k++){
        ctx.beginPath();
        ctx.arc(0,0, innerR + k*34, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${0.14 - k*0.02})`;
        ctx.lineWidth = 6;
        ctx.stroke();
      }

      // center cap
      const hubGrad = ctx.createRadialGradient(0,0,8, 0,0,innerR+24);
      hubGrad.addColorStop(0, "rgba(255,255,255,.95)");
      hubGrad.addColorStop(.25, "rgba(255,255,255,.55)");
      hubGrad.addColorStop(1, "rgba(255,255,255,.08)");
      ctx.beginPath();
      ctx.arc(0,0, innerR+18, 0, Math.PI*2);
      ctx.fillStyle = hubGrad;
      ctx.fill();

      // sparkle
      ctx.beginPath();
      ctx.arc(0,0, 28, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.shadowColor = "rgba(255,255,255,.55)";
      ctx.shadowBlur = 28;
      ctx.fill();
      ctx.restore();

      // labels (the important bit)
      drawLabels(cx,cy,R,innerR, startAngle, step);
    }

    function drawLabels(cx,cy,R,innerR, startAngle, step){
      const n = items.length;

      // label radius in the MIDDLE of each slice (not in the center hub)
      const labelR = innerR + (R - innerR) * 0.62; // <-- FIX: pushes text into each slice
      const maxTextWidth = (R - innerR) * 0.82;    // safe wrap width

      for(let i=0;i<n;i++){
        const mid = startAngle + (i+0.5)*step;
        const txt = (items[i].text || "").trim();

        // choose font size based on slice count + length
        let fs = 34;
        if (n >= 10) fs = 26;
        if (n >= 12) fs = 22;
        if (txt.length > 22) fs -= 3;
        if (txt.length > 34) fs -= 3;
        fs = Math.max(18, fs);

        ctx.save();
        ctx.translate(cx,cy);
        ctx.rotate(mid);

        // draw the text upright-ish (flip if on left side)
        const flip = (mid > Math.PI/2 && mid < 3*Math.PI/2);
        if (flip) ctx.rotate(Math.PI);

        // move outward from center into slice
        ctx.translate(labelR, 0);

        // slight tilt for style
        ctx.rotate(-Math.PI/2);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(0,0,0,.78)";
        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 3;

        // wrap text into lines
        const lines = wrapText(ctx, txt, maxTextWidth, fs);

        // vertical layout
        const lineH = fs * 1.06;
        const totalH = lines.length * lineH;
        let y = -totalH/2 + lineH/2;

        // draw each line with stroke for readability
        ctx.font = `900 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        for(const line of lines){
          ctx.strokeText(line, 0, y);
          ctx.fillText(line, 0, y);
          y += lineH;
        }

        ctx.restore();
      }
    }

    function wrapText(ctx, text, maxWidth, fontSize){
      if(!text) return [""];

      // if you have very long words, this prevents overflow
      const words = text.split(/\s+/g);
      const lines = [];
      let line = "";

      // ensure ctx font is set for measure
      ctx.font = `900 ${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;

      for(const w of words){
        const test = line ? (line + " " + w) : w;
        if(ctx.measureText(test).width <= maxWidth){
          line = test;
        } else {
          if(line) lines.push(line);
          // word itself too big -> hard break
          if(ctx.measureText(w).width > maxWidth){
            lines.push(...hardBreakWord(ctx, w, maxWidth));
            line = "";
          } else {
            line = w;
          }
        }
      }
      if(line) lines.push(line);

      // limit lines a bit (keeps it neat)
      if(lines.length > 4){
        const kept = lines.slice(0,3);
        kept.push(lines.slice(3).join(" "));
        return kept;
      }
      return lines;
    }

    function hardBreakWord(ctx, word, maxWidth){
      const out = [];
      let cur = "";
      for(const ch of word){
        const test = cur + ch;
        if(ctx.measureText(test).width <= maxWidth){
          cur = test;
        } else {
          out.push(cur);
          cur = ch;
        }
      }
      if(cur) out.push(cur);
      return out;
    }

    // ---- Lights (locked to wheel box) ----
    function buildLights(){
      const on = lightsToggle.checked;
      lightsEl.classList.toggle("off", !on);
      if(!on) return;

      lightsEl.innerHTML = "";
      const count = Math.max(18, Math.min(30, items.length * 3));
      for(let i=0;i<count;i++){
        const d = document.createElement('div');
        d.className = "light " + (i%2 ? "dim" : "bright");
        d.dataset.i = String(i);
        lightsEl.appendChild(d);
      }
      positionLights();
    }

    function positionLights(){
      if(lightsEl.classList.contains("off")) return;
      const rect = lightsEl.getBoundingClientRect();
      const cx = rect.width/2, cy = rect.height/2;
      const r = Math.min(rect.width, rect.height) * 0.48;

      const lights = [...lightsEl.querySelectorAll('.light')];
      const count = lights.length || 1;
      lights.forEach((el, i) => {
        const t = (i / count) * Math.PI*2 - Math.PI/2;
        const x = cx + Math.cos(t) * r;
        const y = cy + Math.sin(t) * r;
        el.style.left = (x - 7) + "px";
        el.style.top  = (y - 7) + "px";
      });
    }

    window.addEventListener('resize', positionLights);

    // blink animation
    let blinkT = 0;
    setInterval(() => {
      if(lightsEl.classList.contains("off")) return;
      const lights = [...lightsEl.querySelectorAll('.light')];
      blinkT++;
      lights.forEach((el, i) => {
        const on = ((i + blinkT) % 4) < 2;
        el.style.opacity = on ? "1" : ".55";
      });
    }, 180);

    // ---- Spin logic ----
    let currentAngle = 0; // radians
    function spinToIndex(targetIndex){
      if(spinning) return;
      spinning = true;
      spinBtn.disabled = true;

      const n = items.length;
      const step = (Math.PI*2)/n;

      // pointer at top; want target slice center under pointer
      const startAngle = -Math.PI/2;
      const targetMid = startAngle + (targetIndex + 0.5) * step;

      // We rotate wheel so that targetMid aligns with -PI/2 (pointer).
      // wheel rotation is currentAngle; label angles are drawn in wheel space.
      // For display, we rotate canvas via transform by currentAngle.
      // We'll animate currentAngle to land precisely.
      const extraSpins = 6 + Math.floor(Math.random()*3);
      const desired = (Math.PI*2)*extraSpins + (-Math.PI/2 - targetMid);

      const from = currentAngle;
      const to = from + normalizeAngle(desired);

      const dur = 3600 + Math.random()*700;
      const t0 = performance.now();

      tickSoundStart();

      function anim(t){
        const p = Math.min(1, (t - t0) / dur);
        const e = easeOutCubic(p);
        currentAngle = from + (to - from) * e;
        renderRotated();
        if(p < 1){
          requestAnimationFrame(anim);
        } else {
          spinning = false;
          spinBtn.disabled = false;
          tickSoundStop();
          const picked = items[targetIndex];
          showResult(picked);
          if(confettiToggle.checked) confettiBurst(picked.type);
        }
      }
      requestAnimationFrame(anim);
    }

    function renderRotated(){
      // draw wheel into an offscreen transform by rotating the whole canvas
      const w = 900, h = 900;
      ctx.save();
      ctx.clearRect(0,0,w,h);
      ctx.translate(w/2,h/2);
      ctx.rotate(currentAngle);
      ctx.translate(-w/2,-h/2);

      // draw base wheel in rotated space
      // (call draw but without resetting transform) -> easiest: drawWheelContent()
      drawWheelContent();

      ctx.restore();
    }

    function drawWheelContent(){
      const w = 900, h = 900;
      const cx = w/2, cy = h/2;
      const R = 410;
      const innerR = 88;
      const rimW = 34;

      // rim (no grey overlay)
      ctx.save();
      ctx.translate(cx,cy);
      ctx.beginPath();
      ctx.arc(0,0,R+rimW,0,Math.PI*2);
      ctx.arc(0,0,R-rimW,0,Math.PI*2,true);
      ctx.closePath();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0,0,R+rimW-6,0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 3;
      ctx.stroke();
      ctx.restore();

      const n = Math.max(2, items.length);
      const step = (Math.PI*2)/n;
      const startAngle = -Math.PI/2;

      for(let i=0;i<n;i++){
        const a0 = startAngle + i*step;
        const a1 = a0 + step;
        const [c1,c2] = PALETTE[i % PALETTE.length];

        const grad = ctx.createRadialGradient(cx,cy,innerR, cx,cy,R);
        grad.addColorStop(0, "rgba(255,255,255,.10)");
        grad.addColorStop(.22, c1);
        grad.addColorStop(1, c2);

        ctx.beginPath();
        ctx.moveTo(cx,cy);
        ctx.arc(cx,cy,R,a0,a1);
        ctx.closePath();
        ctx.fillStyle = grad;
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,.35)";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // hub
      ctx.save();
      ctx.translate(cx,cy);
      for(let k=0;k<4;k++){
        ctx.beginPath();
        ctx.arc(0,0, innerR + k*34, 0, Math.PI*2);
        ctx.strokeStyle = `rgba(255,255,255,${0.14 - k*0.02})`;
        ctx.lineWidth = 6;
        ctx.stroke();
      }
      const hubGrad = ctx.createRadialGradient(0,0,8, 0,0,innerR+24);
      hubGrad.addColorStop(0, "rgba(255,255,255,.95)");
      hubGrad.addColorStop(.25, "rgba(255,255,255,.55)");
      hubGrad.addColorStop(1, "rgba(255,255,255,.08)");
      ctx.beginPath();
      ctx.arc(0,0, innerR+18, 0, Math.PI*2);
      ctx.fillStyle = hubGrad;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(0,0, 28, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.shadowColor = "rgba(255,255,255,.55)";
      ctx.shadowBlur = 28;
      ctx.fill();
      ctx.restore();

      drawLabels(cx,cy,R,innerR, startAngle, step);
    }

    function normalizeAngle(a){
      // keep as positive-ish spin
      return a;
    }

    function easeOutCubic(x){
      return 1 - Math.pow(1-x, 3);
    }

    // initial non-rotated draw
    function draw(){
      currentAngle = currentAngle || 0;
      renderRotated();
    }

    // ---- Picking ----
    function pickRandomIndex(){
      return Math.floor(Math.random() * items.length);
    }
    function pickByType(type){
      const idxs = items.map((it,i)=> it.type===type ? i : -1).filter(i=>i>=0);
      if(!idxs.length) return pickRandomIndex();
      return idxs[Math.floor(Math.random()*idxs.length)];
    }

    spinBtn.addEventListener('click', () => spinToIndex(pickRandomIndex()));
    document.getElementById('testWin').addEventListener('click', () => spinToIndex(pickByType("GOOD")));
    document.getElementById('testSkull').addEventListener('click', () => spinToIndex(pickByType("SKULL")));
    document.getElementById('testMystery').addEventListener('click', () => spinToIndex(pickByType("MYSTERY")));

    // ---- Modal ----
    function showResult(item){
      const meta = TYPE_BADGE[item.type] || TYPE_BADGE.GOOD;
      resultTag.textContent = meta.label;
      resultText.textContent = item.text || "";
      resultHint.textContent =
        item.type === "MYSTERY"
          ? "Mystery time ‚Äî parents decide the prize! üòÑ"
          : (item.type === "SKULL" ? "Uh oh‚Ä¶ time to do the thing üòÖ" : "Nice! Enjoy your reward üéâ");
      overlay.classList.add('show');
    }
    closeModal.addEventListener('click', () => overlay.classList.remove('show'));
    overlay.addEventListener('click', (e) => { if(e.target === overlay) overlay.classList.remove('show'); });

    // ---- Confetti (simple) ----
    function confettiBurst(type){
      const count = type === "SKULL" ? 50 : type === "MYSTERY" ? 90 : 120;
      const layer = document.createElement('div');
      layer.style.position = "fixed";
      layer.style.inset = "0";
      layer.style.pointerEvents = "none";
      layer.style.zIndex = "80";
      document.body.appendChild(layer);

      const w = window.innerWidth, h = window.innerHeight;
      for(let i=0;i<count;i++){
        const p = document.createElement('div');
        p.style.position = "absolute";
        p.style.left = (w*0.5 + (Math.random()*220-110)) + "px";
        p.style.top = (h*0.25 + (Math.random()*40-20)) + "px";
        p.style.width = (6 + Math.random()*8) + "px";
        p.style.height = (8 + Math.random()*12) + "px";
        p.style.borderRadius = "3px";
        p.style.background = `hsl(${Math.floor(Math.random()*360)}, 85%, 65%)`;
        p.style.opacity = ".95";
        p.style.transform = `rotate(${Math.random()*360}deg)`;
        layer.appendChild(p);

        const dx = (Math.random()*2-1) * 520;
        const dy = 520 + Math.random()*520;
        const rot = (Math.random()*2-1) * 720;
        const dur = 900 + Math.random()*900;

        p.animate([
          { transform:`translate(0,0) rotate(0deg)`, opacity:.95 },
          { transform:`translate(${dx}px, ${dy}px) rotate(${rot}deg)`, opacity:0 }
        ], { duration: dur, easing: 'cubic-bezier(.15,.7,.25,1)', fill:'forwards' });
      }

      setTimeout(()=> layer.remove(), 2200);
    }

    // ---- Tiny sounds (no files) ----
    let audioCtx = null;
    let tickOsc = null;
    let tickGain = null;

    function tickSoundStart(){
      if(!soundToggle.checked) return;
      try{
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        tickOsc = audioCtx.createOscillator();
        tickGain = audioCtx.createGain();
        tickOsc.type = "triangle";
        tickOsc.frequency.value = 880;
        tickGain.gain.value = 0.0001;
        tickOsc.connect(tickGain).connect(audioCtx.destination);
        tickOsc.start();
        // tiny pulse loop
        let on = false;
        const id = setInterval(() => {
          if(!tickGain){ clearInterval(id); return; }
          on = !on;
          tickGain.gain.setTargetAtTime(on ? 0.04 : 0.001, audioCtx.currentTime, 0.01);
        }, 90);
        tickGain._id = id;
      }catch{}
    }

    function tickSoundStop(){
      try{
        if(tickGain && tickGain._id) clearInterval(tickGain._id);
        if(tickOsc) tickOsc.stop();
        tickOsc = null;
        tickGain = null;
      }catch{}
    }

    // ---- UI helpers ----
    function pulseButton(btn){
      btn.animate([
        { transform:"scale(1)" },
        { transform:"scale(1.03)" },
        { transform:"scale(1)" }
      ], {duration: 240, easing:"ease-out"});
    }

    // toggles
    lightsToggle.addEventListener('change', () => { buildLights(); positionLights(); });
    // (sound/confetti are read live)

    // init
    buildList();
    updateWheelSize();
    buildLights();
    positionLights();
    renderRotated();
  </script>
</body>
</html>
