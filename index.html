<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Killian‚Äôs Spin the Wheel</title>
  <meta name="theme-color" content="#141428" />

  <style>
    :root{
      --bg0:#0b0b18;
      --bg1:#18183a;
      --panel: rgba(255,255,255,.08);
      --panel2: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --glow: 0 18px 60px rgba(0,0,0,.55);
      --radius: 22px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background:
        radial-gradient(1200px 700px at 15% 15%, #3b1f5a 0%, transparent 60%),
        radial-gradient(900px 600px at 85% 35%, #102b5a 0%, transparent 62%),
        radial-gradient(900px 700px at 60% 90%, #153b2f 0%, transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg0));
      overflow-x:hidden;
    }

    /* subtle stars */
    .stars{
      position:fixed; inset:0;
      pointer-events:none;
      background-image:
        radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(1px 1px at 70% 35%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(2px 2px at 85% 65%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 55% 15%, rgba(255,255,255,.14) 45%, transparent 46%),
        radial-gradient(1px 1px at 15% 55%, rgba(255,255,255,.14) 45%, transparent 46%);
      opacity:.65;
      filter: blur(.2px);
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding: 22px 16px 24px;
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
      margin-bottom:14px;
    }

    .brand{
      display:flex;
      gap:12px;
      align-items:flex-start;
    }
    .logo{
      width:46px;height:46px;
      border-radius:14px;
      background: linear-gradient(135deg, rgba(255,255,255,.18), rgba(255,255,255,.06));
      border: 1px solid var(--stroke);
      box-shadow: var(--glow);
      display:grid;place-items:center;
      font-size:22px;
    }
    h1{
      margin:0;
      font-size: clamp(22px, 3.8vw, 38px);
      letter-spacing:.2px;
      line-height:1.05;
    }
    .tagline{
      margin-top:6px;
      color:var(--muted);
      font-size:14px;
    }
    .chips{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 28px rgba(0,0,0,.28);
      user-select:none;
      font-size:13px;
      color: rgba(255,255,255,.82);
    }
    .toggle{
      display:inline-flex;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--stroke);
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 28px rgba(0,0,0,.28);
      user-select:none;
      font-size:14px;
    }
    .toggle input{ width:18px; height:18px; accent-color:#7cf7d3; }

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:16px;
      align-items:start;
      margin-top:10px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--glow);
      backdrop-filter: blur(12px);
      overflow:hidden;
    }

    .card h2{
      margin:0;
      padding:16px 16px 10px;
      font-size:16px;
      letter-spacing:.4px;
      color: rgba(255,255,255,.86);
    }
    .card .sub{
      padding: 0 16px 14px;
      margin-top:-6px;
      color: var(--muted);
      font-size:13px;
    }

    /* LEFT: wheel area */
    .stage{
      padding: 14px 14px 18px;
      position:relative;
      min-height: 520px;
    }

    .topRow{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:space-between;
      margin-bottom:12px;
    }

    .bigBtn{
      border:0;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.8px;
      text-transform:uppercase;
      padding: 14px 18px;
      border-radius: 16px;
      background: linear-gradient(90deg, #7cf7d3, #ffd36a, #ff6ad5);
      color:#101023;
      box-shadow: 0 16px 38px rgba(255,105,208,.16), 0 18px 50px rgba(0,0,0,.35);
      transition: transform .08s ease, filter .2s ease;
      min-width: 210px;
    }
    .bigBtn:active{ transform: translateY(1px) scale(.995); }
    .bigBtn[disabled]{ opacity:.6; cursor:not-allowed; filter:saturate(.6); }

    .smallBtns{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      cursor:pointer;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight:700;
      box-shadow: 0 12px 26px rgba(0,0,0,.26);
    }
    .pill:active{ transform: translateY(1px); }

    .wheelWrap{
      display:grid;
      place-items:center;
      padding: 10px 0 6px;
    }

    /* THIS is the critical part: true square, never distorts */
    .wheelBox{
      width: min(92vw, 640px);
      /* wheel scales down on small screens so it doesn't get cut off */
      max-width: 640px;
      aspect-ratio: 1 / 1;
      position: relative;
      display:grid;
      place-items:center;
      margin: 8px auto 0;
    }

    /* canvas always fills square */
    #wheelCanvas{
      width: 100%;
      height: 100%;
      border-radius: 50%;
      display:block;
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
    }

    /* pointer at top */
    .pointer{
      position:absolute;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 18px solid transparent;
      border-right: 18px solid transparent;
      border-top: 28px solid rgba(255,255,255,.92);
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.45));
      z-index: 5;
    }
    .pointer::after{
      content:"";
      position:absolute;
      left:50%;
      transform: translateX(-50%);
      top:-30px;
      width: 22px; height:22px;
      border-radius: 999px;
      background: rgba(255,255,255,.95);
      box-shadow: 0 10px 20px rgba(0,0,0,.35);
    }

    /* rim lights */
    .lights{
      position:absolute;
      inset:0;
      border-radius:50%;
      pointer-events:none;
      z-index: 4;
    }
    .light{
      position:absolute;
      width: 12px; height: 12px;
      border-radius: 50%;
      background: rgba(255,255,255,.9);
      box-shadow: 0 0 18px rgba(255,255,255,.55);
      opacity:.95;
      transform: translate(-50%,-50%);
      animation: twinkle 1.4s infinite ease-in-out;
    }
    @keyframes twinkle{
      0%,100%{ filter: brightness(.85); transform: translate(-50%,-50%) scale(.92); }
      50%{ filter: brightness(1.25); transform: translate(-50%,-50%) scale(1.08); }
    }

    /* result banner */
    .result{
      margin: 14px auto 0;
      width: min(92vw, 640px);
      border-radius: 16px;
      border: 1px solid var(--stroke);
      background: rgba(0,0,0,.20);
      padding: 12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      box-shadow: 0 12px 26px rgba(0,0,0,.25);
    }
    .result .label{ color: var(--muted); font-size:13px; }
    .result .value{ font-size:16px; font-weight:900; letter-spacing:.2px; }

    /* RIGHT: items editor */
    .editor{
      padding-bottom: 14px;
    }
    .list{
      padding: 0 14px 14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .row{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:center;
      padding:10px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
    }

    .row input[type="text"]{
      width:100%;
      padding: 10px 12px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      color: var(--text);
      outline:none;
      font-weight:700;
    }

    .badge{
      border-radius:999px;
      padding:10px 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      font-weight:900;
      display:inline-flex;
      gap:8px;
      align-items:center;
      cursor:pointer;
      user-select:none;
      min-width: 110px;
      justify-content:center;
    }
    .badge.good{ color:#a7ffe3; }
    .badge.skull{ color:#ff9aa8; }
    .badge.mystery{ color:#ffe08a; }

    .iconBtn{
      width:42px; height:42px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.24);
      color: rgba(255,255,255,.92);
      cursor:pointer;
      font-size:18px;
      font-weight:900;
    }

    .actions{
      padding: 0 14px 14px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
    }
    .actionBtn{
      cursor:pointer;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      padding: 12px 14px;
      border-radius: 14px;
      font-weight:900;
      letter-spacing:.2px;
      box-shadow: 0 12px 26px rgba(0,0,0,.26);
    }
    .actionBtn.primary{
      background: linear-gradient(90deg, rgba(124,247,211,.22), rgba(255,106,213,.18));
      border-color: rgba(255,255,255,.22);
    }

    /* confetti canvas */
    #fx{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index: 50;
    }

    /* mystery overlay */
    .mysteryOverlay{
      position:fixed;
      inset:0;
      display:none;
      place-items:center;
      background: radial-gradient(800px 500px at 50% 45%, rgba(255,214,120,.22), rgba(0,0,0,.74));
      z-index: 60;
      padding: 20px;
    }
    .mysteryCard{
      width: min(560px, 92vw);
      border-radius: 26px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(10,10,28,.62);
      backdrop-filter: blur(12px);
      box-shadow: 0 26px 90px rgba(0,0,0,.6);
      padding: 18px 16px 16px;
      text-align:center;
      position:relative;
      overflow:hidden;
    }
    .mysteryTitle{
      font-size: 22px;
      font-weight:1000;
      letter-spacing:.4px;
      margin: 6px 0 6px;
    }
    .mysteryText{
      color: rgba(255,255,255,.80);
      margin: 0 0 14px;
      line-height:1.35;
      font-weight:700;
    }
    .mysteryAnim{
      height: 110px;
      display:grid;
      place-items:center;
      margin: 6px 0 14px;
      font-size: 72px;
      filter: drop-shadow(0 20px 18px rgba(0,0,0,.35));
      animation: pop 900ms ease-in-out infinite;
    }
    @keyframes pop{
      0%,100%{ transform: translateY(0) rotate(-2deg) scale(1); }
      50%{ transform: translateY(-6px) rotate(2deg) scale(1.08); }
    }
    .mysteryBtns{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }

    /* responsive */
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
      .stage{ min-height: unset; }
      .topRow{ justify-content:center; }
      .smallBtns{ justify-content:center; width:100%; }
      .bigBtn{ width: 100%; max-width: 420px; }
    }

    @media (max-width: 430px){
      .badge{ min-width: 96px; padding:10px 10px; }
      .row{ grid-template-columns: 1fr auto auto; }
      .chip{ font-size:12px; }
    }
  </style>
</head>

<body>
  <canvas id="fx"></canvas>
  <div class="stars"></div>

  <div class="wrap">
    <header>
      <div class="brand">
        <div class="logo">üé∞</div>
        <div>
          <h1>Killian‚Äôs Spin the Wheel</h1>
          <div class="tagline">Spin for a reward‚Ä¶ unless it lands on the üíÄ skull!</div>
        </div>
      </div>

      <div class="chips">
        <div class="chip">offline ‚Ä¢ single file ‚Ä¢ parent-approved</div>
        <label class="toggle"><input id="soundToggle" type="checkbox" checked> üîä <b>Sound</b></label>
        <label class="toggle"><input id="confettiToggle" type="checkbox" checked> üéâ <b>Confetti</b></label>
      </div>
    </header>

    <section class="grid">
      <div class="card stage">
        <div class="topRow">
          <button id="spinBtn" class="bigBtn">SPIN THE WHEEL</button>
          <div class="smallBtns">
            <button class="pill" id="testWin">Test WIN üéÅ</button>
            <button class="pill" id="testSkull">Test SKULL üíÄ</button>
            <button class="pill" id="testMystery">Test MYSTERY ‚ùì</button>
          </div>
        </div>

        <div class="wheelWrap">
          <div class="wheelBox" id="wheelBox">
            <div class="pointer"></div>
            <canvas id="wheelCanvas" aria-label="Spin wheel"></canvas>
            <div class="lights" id="lights"></div>
          </div>

          <div class="result">
            <div>
              <div class="label">Result</div>
              <div class="value" id="resultValue">‚Äî</div>
            </div>
            <div class="label" id="resultHint">Tap ‚ÄúSPIN THE WHEEL‚Äù</div>
          </div>
        </div>
      </div>

      <div class="card editor">
        <h2>WHEEL ITEMS</h2>
        <div class="sub">
          Edit the text. Mark items as <b>GOOD</b> (reward), <b>SKULL</b> (a ‚Äúdo it‚Äù task),
          or <b>MYSTERY</b> (parents decide). Then click <b>Update Wheel</b>.
        </div>

        <div class="list" id="list"></div>

        <div class="actions">
          <button class="actionBtn" id="addGood">+ Add GOOD</button>
          <button class="actionBtn" id="addSkull">+ Add SKULL</button>
          <button class="actionBtn" id="addMystery">+ Add MYSTERY</button>
          <button class="actionBtn primary" id="apply">Update Wheel</button>
        </div>
      </div>
    </section>
  </div>

  <!-- Mystery overlay -->
  <div class="mysteryOverlay" id="mysteryOverlay" role="dialog" aria-modal="true">
    <div class="mysteryCard">
      <div class="mysteryTitle">üéÅ Mystery Prize!</div>
      <div class="mysteryText">Parents decide what it is. (This is the ‚Äúsurprise‚Äù space.)</div>
      <div class="mysteryAnim" id="mysteryAnim">üé≤</div>
      <div class="mysteryBtns">
        <button class="actionBtn primary" id="mysteryDone">OK!</button>
      </div>
    </div>
  </div>

  <script>
    /***********************
     * Data + persistence
     ***********************/
    const STORAGE_KEY = "killians_spin_wheel_v3";

    const defaultItems = [
      { text: "Chocolate ice cream", type: "good" },
      { text: "Play Xbox for 20 minutes", type: "good" },
      { text: "Later bedtime", type: "good" },
      { text: "Dance party üéµ", type: "good" },
      { text: "Minecraft skins", type: "good" },
      { text: "MYSTERY Prize (Parents‚Ä¶)", type: "mystery" },
      { text: "SKULL: Clean toys üß∏", type: "skull" },
      { text: "SKULL: Take a shower üöø", type: "skull" },
    ];

    function loadItems(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return structuredClone(defaultItems);
        const parsed = JSON.parse(raw);
        if(!Array.isArray(parsed) || parsed.length < 2) return structuredClone(defaultItems);
        return parsed.map(x => ({
          text: String(x.text ?? "").slice(0, 80),
          type: (x.type === "skull" || x.type === "mystery") ? x.type : "good"
        }));
      }catch{
        return structuredClone(defaultItems);
      }
    }

    function saveItems(items){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
    }

    let items = loadItems();

    /***********************
     * UI: editor list
     ***********************/
    const listEl = document.getElementById("list");

    function typeLabel(t){
      if(t === "skull") return "üíÄ SKULL";
      if(t === "mystery") return "‚ùì MYSTERY";
      return "üéÅ GOOD";
    }

    function renderList(){
      listEl.innerHTML = "";
      items.forEach((it, idx) => {
        const row = document.createElement("div");
        row.className = "row";

        const input = document.createElement("input");
        input.type = "text";
        input.value = it.text;
        input.maxLength = 80;
        input.addEventListener("input", () => {
          items[idx].text = input.value;
          saveItems(items);
          drawWheel();
        });

        const badge = document.createElement("button");
        badge.type = "button";
        badge.className = "badge " + it.type;
        badge.textContent = typeLabel(it.type);
        badge.addEventListener("click", () => {
          const order = ["good","skull","mystery"];
          const next = order[(order.indexOf(items[idx].type)+1) % order.length];
          items[idx].type = next;
          badge.className = "badge " + next;
          badge.textContent = typeLabel(next);
          saveItems(items);
          drawWheel();
        });

        const del = document.createElement("button");
        del.type = "button";
        del.className = "iconBtn";
        del.textContent = "‚úï";
        del.title = "Remove";
        del.addEventListener("click", () => {
          if(items.length <= 2) return;
          items.splice(idx,1);
          saveItems(items);
          renderList();
          drawWheel();
        });

        row.appendChild(input);
        row.appendChild(badge);
        row.appendChild(del);
        listEl.appendChild(row);
      });
    }

    document.getElementById("addGood").addEventListener("click", () => {
      items.push({text:"New reward üéÅ", type:"good"});
      saveItems(items);
      renderList(); drawWheel();
    });
    document.getElementById("addSkull").addEventListener("click", () => {
      items.push({text:"SKULL: New task üíÄ", type:"skull"});
      saveItems(items);
      renderList(); drawWheel();
    });
    document.getElementById("addMystery").addEventListener("click", () => {
      items.push({text:"MYSTERY Prize (Parents‚Ä¶)", type:"mystery"});
      saveItems(items);
      renderList(); drawWheel();
    });
    document.getElementById("apply").addEventListener("click", () => {
      // just re-draw (items already saved as you type)
      drawWheel();
      flashHint("Wheel updated ‚úÖ");
    });

    /***********************
     * Wheel (Canvas)
     ***********************/
    const canvas = document.getElementById("wheelCanvas");
    const wheelBox = document.getElementById("wheelBox");
    const ctx = canvas.getContext("2d");

    const resultValue = document.getElementById("resultValue");
    const resultHint  = document.getElementById("resultHint");

    let spinning = false;
    let rotation = 0; // radians
    let targetRotation = 0;
    let spinStart = 0;
    let spinDuration = 0;

    function resizeCanvas(){
      // true square based on wheelBox rendered size
      const r = wheelBox.getBoundingClientRect();
      const size = Math.floor(Math.min(r.width, r.height));
      const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      canvas.style.width = size + "px";
      canvas.style.height = size + "px";
      ctx.setTransform(dpr,0,0,dpr,0,0);
      drawWheel();
      buildLights(); // keep lights aligned to the new rim
    }

    const paletteGood = ["#4ef0c5","#41e3ff","#7a70ff","#ff6ad5","#ffcc66","#57ffa7","#76b8ff","#b67bff"];
    const paletteSkull = ["#ff4a7a","#ff5e6a","#ff4670","#ff6a80"];
    const paletteMyst  = ["#ffe08a","#ffd26a","#fff0a8"];

    function colorFor(i, type){
      if(type === "skull") return paletteSkull[i % paletteSkull.length];
      if(type === "mystery") return paletteMyst[i % paletteMyst.length];
      return paletteGood[i % paletteGood.length];
    }

    function drawWheel(){
      const size = Math.min(canvas.width, canvas.height) / (window.devicePixelRatio || 1);
      const cx = size/2, cy = size/2;
      const radius = size * 0.48;   // leave room for glow/rim
      const rim = size * 0.02;

      ctx.clearRect(0,0,size,size);

      // outer shadow ring
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx,cy,radius + rim*2.1,0,Math.PI*2);
      ctx.fillStyle = "rgba(0,0,0,.30)";
      ctx.fill();
      ctx.restore();

      // wheel background
      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(rotation);

      const n = Math.max(2, items.length);
      const slice = (Math.PI*2)/n;

      for(let i=0;i<n;i++){
        const it = items[i];
        const a0 = i*slice;
        const a1 = a0 + slice;

        // slice
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0,radius,a0,a1,false);
        ctx.closePath();

        // slice gradient
        const grad = ctx.createRadialGradient(0,0,radius*0.08, 0,0,radius);
        const base = colorFor(i, it.type);
        grad.addColorStop(0, "rgba(255,255,255,.18)");
        grad.addColorStop(0.12, base);
        grad.addColorStop(1, "rgba(0,0,0,.20)");
        ctx.fillStyle = grad;
        ctx.fill();

        // slice border
        ctx.strokeStyle = "rgba(0,0,0,.30)";
        ctx.lineWidth = Math.max(1, radius*0.012);
        ctx.stroke();

        // text
        const mid = (a0+a1)/2;
        const textRadius = radius * 0.70;

        ctx.save();
        ctx.rotate(mid);
        ctx.translate(textRadius, 0);
        ctx.rotate(Math.PI/2); // upright relative to radius

        let label = String(it.text || "");
        // tiny cleanup for consistent mystery label
        if(it.type === "mystery" && !/mystery/i.test(label)) label = "MYSTERY: " + label;

        // draw wrapped/fit text inside slice
        drawSliceText(label, radius, slice);

        ctx.restore();
      }

      ctx.restore();

      // center cap
      ctx.save();
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.22,0,Math.PI*2);
      const cg = ctx.createRadialGradient(cx,cy,radius*0.02, cx,cy,radius*0.22);
      cg.addColorStop(0, "rgba(255,255,255,.92)");
      cg.addColorStop(0.35, "rgba(255,255,255,.35)");
      cg.addColorStop(1, "rgba(0,0,0,.25)");
      ctx.fillStyle = cg;
      ctx.fill();

      // inner ring
      ctx.beginPath();
      ctx.arc(cx,cy,radius*0.29,0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = radius*0.03;
      ctx.stroke();

      // rim
      ctx.beginPath();
      ctx.arc(cx,cy,radius + rim,0,Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = rim*3.2;
      ctx.stroke();

      ctx.restore();
    }

    function drawSliceText(text, radius, sliceAngle){
      // available width roughly proportional to arc length at textRadius
      const maxWidth = radius * 0.46;
      const maxLines = 3;

      // start with a strong, readable font size, then shrink if needed
      let fontSize = Math.max(12, Math.min(22, radius * 0.09));
      ctx.fillStyle = "rgba(0,0,0,.78)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      // wrap into lines
      function wrapLines(fs){
        ctx.font = `900 ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        const words = text.replace(/\s+/g," ").trim().split(" ");
        const lines = [];
        let line = "";
        for(const w of words){
          const test = line ? (line + " " + w) : w;
          if(ctx.measureText(test).width <= maxWidth){
            line = test;
          }else{
            if(line) lines.push(line);
            line = w;
          }
        }
        if(line) lines.push(line);

        // if too many lines, try to compress by allowing longer lines
        if(lines.length > maxLines){
          return null;
        }
        return lines;
      }

      let lines = wrapLines(fontSize);
      while(!lines && fontSize > 11){
        fontSize -= 1;
        lines = wrapLines(fontSize);
      }
      if(!lines){
        // fallback: hard cut
        ctx.font = `900 12px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        lines = [text.slice(0, 18) + (text.length>18 ? "‚Ä¶" : "")];
        fontSize = 12;
      }

      const lineH = fontSize * 1.08;
      const totalH = lineH * lines.length;

      // slight angle-based squeeze (narrow slices => smaller)
      const squeeze = Math.max(0.72, Math.min(1, sliceAngle / (Math.PI/4)));
      ctx.scale(squeeze, 1);

      // subtle shadow for readability
      ctx.save();
      ctx.shadowColor = "rgba(255,255,255,.35)";
      ctx.shadowBlur = 6;
      ctx.shadowOffsetX = 0;
      ctx.shadowOffsetY = 0;

      // draw
      for(let i=0;i<lines.length;i++){
        const y = (i * lineH) - (totalH/2) + (lineH/2);
        ctx.fillText(lines[i], 0, y);
      }
      ctx.restore();
    }

    /***********************
     * Lights (perfect rim)
     ***********************/
    const lightsEl = document.getElementById("lights");

    function buildLights(){
      lightsEl.innerHTML = "";
      const rect = wheelBox.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height);
      const cx = size/2, cy = size/2;
      const r = size * 0.49; // just outside canvas rim
      const count = 22;

      for(let i=0;i<count;i++){
        const a = (Math.PI*2) * (i / count) - Math.PI/2;
        const x = cx + Math.cos(a) * r;
        const y = cy + Math.sin(a) * r;

        const d = document.createElement("div");
        d.className = "light";
        d.style.left = x + "px";
        d.style.top = y + "px";
        d.style.animationDelay = (Math.random()*1.1) + "s";
        d.style.opacity = (0.75 + Math.random()*0.25).toFixed(2);
        lightsEl.appendChild(d);
      }
    }

    /***********************
     * Spin logic
     ***********************/
    const spinBtn = document.getElementById("spinBtn");

    function pickIndex(){
      // simple even odds
      return Math.floor(Math.random() * items.length);
    }

    function spinToIndex(idx){
      const n = items.length;
      const slice = (Math.PI*2)/n;

      // pointer is at -90deg; we want selected slice mid to land there
      const midAngle = idx*slice + slice/2;
      const desired = (-Math.PI/2) - midAngle;

      const extraSpins = 5 + Math.random()*2.5;
      const current = rotation % (Math.PI*2);
      // normalize target to be forward
      const target = (rotation - current) + (extraSpins * Math.PI*2) + desired;

      targetRotation = target;
      spinStart = performance.now();
      spinDuration = 3600 + Math.random()*900;

      spinning = true;
      spinBtn.disabled = true;
      resultHint.textContent = "Spinning‚Ä¶";
      if(soundOn()) tickStart();

      requestAnimationFrame(step);
    }

    function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

    function step(now){
      const t = Math.min(1, (now - spinStart) / spinDuration);
      const e = easeOutCubic(t);
      rotation = rotation + (targetRotation - rotation) * e; // smooth chase
      drawWheel();

      if(soundOn()) tickDuring(t);

      if(t < 1){
        requestAnimationFrame(step);
      }else{
        spinning = false;
        spinBtn.disabled = false;
        rotation = targetRotation; // snap
        drawWheel();
        settleResult();
      }
    }

    function settleResult(){
      const idx = indexAtPointer();
      const it = items[idx];
      resultValue.textContent = it.text;
      if(it.type === "skull"){
        resultHint.textContent = "Uh oh‚Ä¶ skull task time üíÄ";
        if(confettiOn()) confetti(false);
        if(soundOn()) buzz();
      }else if(it.type === "mystery"){
        resultHint.textContent = "Mystery time! Parents decide üéÅ";
        if(soundOn()) mysterySound();
        showMystery();
        if(confettiOn()) confetti(true);
      }else{
        resultHint.textContent = "Nice! You got a reward üéâ";
        if(confettiOn()) confetti(true);
        if(soundOn()) winSound();
      }
    }

    function indexAtPointer(){
      const n = items.length;
      const slice = (Math.PI*2)/n;

      // pointer angle in wheel space: -90deg, but wheel rotated by rotation
      // Equivalent: which slice contains angle = (-90deg - rotation)
      let ang = (-Math.PI/2) - rotation;
      // normalize 0..2pi
      ang = ((ang % (Math.PI*2)) + (Math.PI*2)) % (Math.PI*2);

      // slice i covers [i*slice, (i+1)*slice)
      const idx = Math.floor(ang / slice);
      return Math.max(0, Math.min(n-1, idx));
    }

    spinBtn.addEventListener("click", () => {
      if(spinning) return;
      spinToIndex(pickIndex());
    });

    document.getElementById("testWin").addEventListener("click", () => {
      const idx = items.findIndex(x => x.type === "good");
      if(idx >= 0) spinToIndex(idx); else spinToIndex(0);
    });
    document.getElementById("testSkull").addEventListener("click", () => {
      const idx = items.findIndex(x => x.type === "skull");
      if(idx >= 0) spinToIndex(idx); else spinToIndex(0);
    });
    document.getElementById("testMystery").addEventListener("click", () => {
      const idx = items.findIndex(x => x.type === "mystery");
      if(idx >= 0) spinToIndex(idx); else spinToIndex(0);
    });

    function flashHint(msg){
      const old = resultHint.textContent;
      resultHint.textContent = msg;
      setTimeout(() => resultHint.textContent = old, 1300);
    }

    /***********************
     * Sound (no external files)
     ***********************/
    const soundToggle = document.getElementById("soundToggle");
    const confettiToggle = document.getElementById("confettiToggle");

    function soundOn(){ return !!soundToggle.checked; }
    function confettiOn(){ return !!confettiToggle.checked; }

    let ac;
    function getAC(){
      if(!ac) ac = new (window.AudioContext || window.webkitAudioContext)();
      return ac;
    }
    function beep(freq, duration=0.08, type="sine", gain=0.06){
      const ctx = getAC();
      const t0 = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0, t0);
      g.gain.linearRampToValueAtTime(gain, t0+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0+duration);
      o.connect(g).connect(ctx.destination);
      o.start(t0);
      o.stop(t0+duration+0.02);
    }
    function tickStart(){
      try{ getAC().resume(); }catch{}
      beep(520,0.08,"square",0.03);
    }
    function tickDuring(t){
      // sparse ticks early, faster near end
      const speed = 6 + t*18;
      if(Math.random() < (speed/120)){
        beep(680 + Math.random()*120, 0.04, "square", 0.02);
      }
    }
    function winSound(){
      try{ getAC().resume(); }catch{}
      beep(660,0.09,"triangle",0.05);
      setTimeout(()=>beep(880,0.10,"triangle",0.06), 90);
      setTimeout(()=>beep(1040,0.12,"triangle",0.06), 200);
    }
    function buzz(){
      try{ getAC().resume(); }catch{}
      beep(160,0.12,"sawtooth",0.06);
      setTimeout(()=>beep(130,0.14,"sawtooth",0.06), 130);
    }
    function mysterySound(){
      try{ getAC().resume(); }catch{}
      beep(520,0.06,"triangle",0.05);
      setTimeout(()=>beep(740,0.06,"triangle",0.05), 70);
      setTimeout(()=>beep(980,0.08,"triangle",0.05), 140);
    }

    /***********************
     * Confetti
     ***********************/
    const fx = document.getElementById("fx");
    const fxCtx = fx.getContext("2d");
    let confettiPieces = [];
    let confettiRunning = false;

    function resizeFX(){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      fx.width = Math.floor(innerWidth * dpr);
      fx.height = Math.floor(innerHeight * dpr);
      fx.style.width = innerWidth + "px";
      fx.style.height = innerHeight + "px";
      fxCtx.setTransform(dpr,0,0,dpr,0,0);
    }

    function confetti(big=true){
      const n = big ? 180 : 40;
      confettiPieces = [];
      for(let i=0;i<n;i++){
        confettiPieces.push({
          x: innerWidth * (0.25 + Math.random()*0.5),
          y: innerHeight * (0.15 + Math.random()*0.1),
          vx: (Math.random()*2-1) * (big?4:2),
          vy: Math.random()*-6 - (big?6:3),
          g: 0.22 + Math.random()*0.25,
          s: 4 + Math.random()*6,
          r: Math.random()*Math.PI*2,
          vr: (Math.random()*2-1) * 0.2,
          a: 1
        });
      }
      confettiRunning = true;
      requestAnimationFrame(confettiStep);
      setTimeout(()=>{ confettiRunning=false; }, big ? 1600 : 900);
    }

    function confettiStep(){
      fxCtx.clearRect(0,0,innerWidth,innerHeight);
      for(const p of confettiPieces){
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.r += p.vr;
        p.a *= 0.992;

        fxCtx.save();
        fxCtx.translate(p.x, p.y);
        fxCtx.rotate(p.r);
        fxCtx.globalAlpha = p.a;
        fxCtx.fillRect(-p.s/2, -p.s/2, p.s, p.s);
        fxCtx.restore();
      }
      confettiPieces = confettiPieces.filter(p => p.y < innerHeight+60 && p.a > 0.06);
      if(confettiRunning || confettiPieces.length){
        requestAnimationFrame(confettiStep);
      }else{
        fxCtx.clearRect(0,0,innerWidth,innerHeight);
      }
    }

    /***********************
     * Mystery overlay (different emojis)
     ***********************/
    const overlay = document.getElementById("mysteryOverlay");
    const mysteryAnim = document.getElementById("mysteryAnim");
    const mysteryDone = document.getElementById("mysteryDone");

    const mysteryEmojis = ["üé≤","üéÅ","ü™Ñ","üåü","üçÄ","üëë","üß©","üöÄ"];
    let mysteryTimer = null;

    function showMystery(){
      overlay.style.display = "grid";
      let i = 0;
      clearInterval(mysteryTimer);
      mysteryAnim.textContent = mysteryEmojis[Math.floor(Math.random()*mysteryEmojis.length)];
      mysteryTimer = setInterval(()=>{
        i++;
        mysteryAnim.textContent = mysteryEmojis[i % mysteryEmojis.length];
      }, 220);
    }

    function hideMystery(){
      overlay.style.display = "none";
      clearInterval(mysteryTimer);
      mysteryTimer = null;
    }

    mysteryDone.addEventListener("click", hideMystery);
    overlay.addEventListener("click", (e) => {
      if(e.target === overlay) hideMystery();
    });

    /***********************
     * Init
     ***********************/
    function init(){
      renderList();
      resizeFX();
      resizeCanvas();
      window.addEventListener("resize", () => {
        resizeFX();
        resizeCanvas();
      }, {passive:true});
    }

    init();
  </script>
</body>
</html>
