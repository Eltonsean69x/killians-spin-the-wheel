<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Killian‚Äôs Spin the Wheel</title>
  <style>
    :root{
      --bg1:#070a1a;
      --bg2:#1a0b2e;
      --card:rgba(255,255,255,.08);
      --card2:rgba(255,255,255,.12);
      --stroke:rgba(255,255,255,.14);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --good:#2ef2a1;
      --skull:#ff4b8a;
      --myst:#ffd34d;
      --shadow: 0 20px 60px rgba(0,0,0,.55);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1000px 600px at 20% 15%, rgba(255,120,220,.18), transparent 60%),
        radial-gradient(900px 500px at 80% 20%, rgba(90,220,255,.14), transparent 60%),
        radial-gradient(700px 420px at 70% 80%, rgba(255,210,70,.10), transparent 60%),
        linear-gradient(160deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
    }

    /* subtle stars */
    .stars{
      position:fixed; inset:0;
      pointer-events:none;
      background-image:
        radial-gradient(2px 2px at 10% 20%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(1px 1px at 70% 35%, rgba(255,255,255,.18) 45%, transparent 46%),
        radial-gradient(2px 2px at 85% 65%, rgba(255,255,255,.22) 45%, transparent 46%),
        radial-gradient(1px 1px at 55% 15%, rgba(255,255,255,.14) 45%, transparent 46%),
        radial-gradient(1px 1px at 15% 55%, rgba(255,255,255,.14) 45%, transparent 46%);
      opacity:.75;
      filter: blur(.2px);
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:22px 18px 36px;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      margin-bottom:16px;
    }

    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size:clamp(22px, 2.2vw + 14px, 36px);
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }
    .subtitle{
      color:var(--muted);
      margin:0;
      font-size:14px;
    }

    .toggles{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .toggle{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(0,0,0,.18);
      border:1px solid var(--stroke);
      user-select:none;
    }
    .toggle input{width:16px;height:16px}

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns:1fr}
    }

    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border:1px solid var(--stroke);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .card .inner{
      padding:16px;
    }

    /* LEFT: wheel */
    .wheelArea{
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }

    .topControls{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }

    .bigBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      padding:14px 18px;
      border-radius:16px;
      border:0;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.6px;
      font-size:16px;
      color:#0b1222;
      background:linear-gradient(90deg, #66ffd2, #ffd34d, #ff5bd1);
      box-shadow: 0 10px 30px rgba(255,140,220,.25);
      transition: transform .08s ease, filter .2s ease;
      user-select:none;
    }
    .bigBtn:active{transform:translateY(1px) scale(.99)}
    .bigBtn[disabled]{opacity:.55; cursor:not-allowed; filter:saturate(.6)}
    .smallBtns{
      display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;
    }
    .pillBtn{
      padding:10px 14px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      transition: transform .08s ease, background .2s ease;
      user-select:none;
    }
    .pillBtn:hover{background:rgba(0,0,0,.26)}
    .pillBtn:active{transform:translateY(1px)}

    .wheel-wrap{
    width: min(520px, 92vw);
    height: min(520px, 92vw, 65vh);
    aspect-ratio: 1 / 1;
    position: relative;
    margin: 0 auto;
}

    /* pointer */
    .pointer{
      position:absolute;
      top:22px;
      left:50%;
      transform:translateX(-50%);
      width:0;height:0;
      border-left:18px solid transparent;
      border-right:18px solid transparent;
      border-top:28px solid rgba(255,255,255,.95);
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.6));
      z-index:6;
    }
    .pointer:after{
      content:"";
      position:absolute;
      left:-10px; top:-26px;
      width:20px; height:20px;
      background:rgba(255,255,255,.92);
      border-radius:999px;
      border:1px solid rgba(0,0,0,.25);
      box-shadow: 0 6px 12px rgba(0,0,0,.35);
    }

    /* wheel canvas */
    .wheelCanvas{
      width:min(560px, 92vw);
      aspect-ratio:1/1;
      border-radius:999px;
      display:block;
      position:relative;
      z-index:3;
      filter: drop-shadow(0 22px 40px rgba(0,0,0,.65));
    }

    /* flashy ‚Äúbulb lights‚Äù ring */
    .bulbRing{
      position:absolute;
      width:min(610px, 96vw);
      aspect-ratio:1/1;
      border-radius:999px;
      z-index:2;
      pointer-events:none;
      display:block;
    }
    .bulb{
      position:absolute;
      width:12px; height:12px;
      border-radius:999px;
      transform: translate(-50%,-50%);
      box-shadow: 0 0 16px rgba(255,255,255,.35);
      opacity:.95;
      filter:saturate(1.15);
      animation: blink 1.2s linear infinite;
    }
    .bulb.alt{animation-delay:.6s}
    .bulb.fast{animation-duration:.38s}
    .bulb.fast.alt{animation-delay:.19s}

    @keyframes blink{
      0%{filter:brightness(1); opacity:.85}
      50%{filter:brightness(2.1); opacity:1}
      100%{filter:brightness(1); opacity:.85}
    }

    .hint{
      text-align:center;
      color:var(--muted);
      font-size:13px;
      margin-top:6px;
    }

    /* RIGHT: item editor */
    .rightHeader{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
      padding:16px 16px 0;
    }
    .rightHeader h2{
      margin:0;
      font-size:18px;
      letter-spacing:.3px;
    }
    .rightHeader p{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.35;
    }

    .items{
      padding:12px 16px 16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr auto auto;
      gap:10px;
      align-items:center;
      padding:10px;
      border-radius:16px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.14);
    }
    .row input[type="text"]{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--text);
      outline:none;
      font-weight:650;
    }
    .tagBtn{
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--text);
      cursor:pointer;
      font-weight:900;
      min-width:98px;
      text-align:center;
      user-select:none;
    }
    .tagGood{border-color: rgba(46,242,161,.35)}
    .tagSkull{border-color: rgba(255,75,138,.35)}
    .tagMyst{border-color: rgba(255,211,77,.45)}
    .delBtn{
      width:42px; height:42px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      color:var(--text);
      cursor:pointer;
      font-size:18px;
      font-weight:900;
      user-select:none;
    }
    .delBtn[disabled]{opacity:.4; cursor:not-allowed}

    .actions{
      padding:0 16px 16px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .actionBtn{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid var(--stroke);
      background:rgba(0,0,0,.18);
      color:var(--text);
      cursor:pointer;
      font-weight:900;
      user-select:none;
    }
    .actionBtn.primary{
      border:0;
      color:#0b1222;
      background:linear-gradient(90deg, #66ffd2, #ffd34d);
      box-shadow: 0 10px 28px rgba(255,211,77,.16);
    }

    /* result overlay */
    .overlay{
      position:fixed; inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:50;
    }
    .overlay.show{display:flex}
    .modal{
      width:min(720px, 96vw);
      border-radius:22px;
      border:1px solid rgba(255,255,255,.16);
      background:linear-gradient(180deg, rgba(20,20,35,.92), rgba(12,12,22,.92));
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }
    .modalTop{
      padding:16px 18px 8px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .modalTop h3{
      margin:0;
      font-size:18px;
      letter-spacing:.3px;
    }
    .closeX{
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.2);
      color:var(--text);
      border-radius:12px;
      width:42px;height:42px;
      cursor:pointer;
      font-size:18px;
      font-weight:900;
    }
    .modalBody{
      padding:16px 18px 18px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .bigResult{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.18);
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:center;
      justify-content:center;
      text-align:center;
      min-height:160px;
      position:relative;
      overflow:hidden;
    }
    .bigResult .label{
      font-size:13px;
      color:var(--muted);
      font-weight:800;
      letter-spacing:.6px;
      text-transform:uppercase;
    }
    .bigResult .value{
      font-size: clamp(24px, 2.2vw + 18px, 40px);
      font-weight:1000;
      letter-spacing:.3px;
    }
    .bigResult.good{outline:2px solid rgba(46,242,161,.22)}
    .bigResult.skull{outline:2px solid rgba(255,75,138,.22)}
    .bigResult.myst{outline:2px solid rgba(255,211,77,.26)}
    .modalActions{
      display:flex;
      gap:10px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .modalActions button{
      padding:12px 14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.2);
      color:var(--text);
      cursor:pointer;
      font-weight:900;
    }
    .modalActions button.primary{
      border:0;
      color:#0b1222;
      background:linear-gradient(90deg, #ffd34d, #ff5bd1);
    }

    /* Mystery animation */
    .mystFX{
      position:absolute; inset:-40%;
      background:
        radial-gradient(120px 120px at 25% 30%, rgba(255,211,77,.34), transparent 60%),
        radial-gradient(140px 140px at 70% 40%, rgba(255,100,220,.22), transparent 60%),
        radial-gradient(120px 120px at 50% 75%, rgba(90,220,255,.18), transparent 60%);
      filter: blur(2px);
      opacity:.0;
      transform: rotate(0deg);
      pointer-events:none;
    }
    .bigResult.myst .mystFX{
      opacity:.9;
      animation: swirl 1.1s linear infinite;
    }
    @keyframes swirl{
      0%{transform: rotate(0deg)}
      100%{transform: rotate(360deg)}
    }
    .qm{
      font-size:64px;
      font-weight:1000;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      animation: pop 1.2s ease-in-out infinite;
    }
    @keyframes pop{
      0%,100%{transform:scale(1) rotate(-6deg)}
      50%{transform:scale(1.12) rotate(6deg)}
    }

    /* Confetti canvas */
    #confetti{
      position:fixed; inset:0;
      pointer-events:none;
      z-index:60;
      display:none;
    }
    #confetti.show{display:block}
  </style>
</head>

<body>
  <div class="stars"></div>
  <canvas id="confetti"></canvas>

  <div class="wrap">
    <header>
      <div class="title">
        <h1>üé° Killian‚Äôs Spin the Wheel <span class="badge">offline ‚Ä¢ single file ‚Ä¢ parent-approved</span></h1>
        <p class="subtitle">Spin for a reward‚Ä¶ unless it lands on the üíÄ skull!</p>
      </div>

      <div class="toggles">
        <label class="toggle"><input id="soundToggle" type="checkbox" checked> üîä Sound</label>
        <label class="toggle"><input id="confettiToggle" type="checkbox" checked> üéâ Confetti</label>
      </div>
    </header>

    <div class="grid">
      <!-- LEFT -->
      <section class="card">
        <div class="inner wheelArea">
          <div class="topControls">
            <button id="spinBtn" class="bigBtn">SPIN THE WHEEL</button>
            <div class="smallBtns">
              <button id="testWin" class="pillBtn">Test WIN üéÅ</button>
              <button id="testSkull" class="pillBtn">Test SKULL üíÄ</button>
              <button id="testMyst" class="pillBtn">Test MYSTERY ‚ùì</button>
            </div>
          </div>

          <div class="wheelWrap">
            <div class="pointer"></div>
            <div id="bulbRing" class="bulbRing" aria-hidden="true"></div>
            <canvas id="wheel" class="wheelCanvas" width="900" height="900"></canvas>
          </div>

          <div class="hint">Tip: edit rewards/tasks on the right ‚Äî long text will wrap + shrink to fit better.</div>
        </div>
      </section>

      <!-- RIGHT -->
      <section class="card">
        <div class="rightHeader">
          <div>
            <h2>WHEEL ITEMS</h2>
            <p>Edit the text. Mark items as <b>GOOD</b> (reward) or <b>SKULL</b> (a ‚Äúdo it‚Äù task).<br>
               <b>Mystery Prize</b> is special ‚Äî parents decide the real prize after it lands.</p>
          </div>
        </div>

        <div id="items" class="items"></div>

        <div class="actions">
          <button id="addItem" class="actionBtn">+ Add Item</button>
          <button id="saveWheel" class="actionBtn primary">Update Wheel</button>
          <button id="resetWheel" class="actionBtn">Reset Defaults</button>
        </div>
      </section>
    </div>
  </div>

  <!-- RESULT MODAL -->
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Spin result">
    <div class="modal">
      <div class="modalTop">
        <h3 id="resultTitle">Result</h3>
        <button id="closeOverlay" class="closeX">‚úï</button>
      </div>
      <div class="modalBody">
        <div id="resultCard" class="bigResult">
          <div class="mystFX"></div>
          <div class="label" id="resultLabel">YOU GOT</div>
          <div class="value" id="resultValue">‚Äî</div>
          <div id="mystExtra" style="display:none; margin-top:6px;">
            <div class="qm">‚ùì</div>
          </div>
        </div>

        <div class="modalActions">
          <button id="spinAgain" class="primary">Spin Again</button>
          <button id="revealMyst" style="display:none;">Reveal (Parents)</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    /***********************
     *  Killian‚Äôs Wheel
     *  Single-file offline
     ***********************/

    // ---------- DEFAULTS ----------
    const DEFAULT_ITEMS = [
      { text: "Chocolate ice cream", type: "GOOD", weight: 1 },
      { text: "Play Xbox for 20 minutes", type: "GOOD", weight: 1 },
      { text: "Later bedtime", type: "GOOD", weight: 1 },
      { text: "Dance party üéµ", type: "GOOD", weight: 1 },
      { text: "Minecraft skins", type: "GOOD", weight: 1 },
      { text: "SKULL: Clean toys üß∏", type: "SKULL", weight: 1 },
      { text: "SKULL: Take a shower üöø", type: "SKULL", weight: 1 },
      { text: "Mystery Prize (Parents decide!)", type: "MYSTERY", weight: 1 }
    ];

    const STORAGE_KEY = "killians_wheel_v2";

    // ---------- STATE ----------
    let items = loadItems();
    let spinning = false;

    // wheel drawing
    const wheelCanvas = document.getElementById("wheel");
    const ctx = wheelCanvas.getContext("2d");
    let rotation = 0; // radians
    let spinRAF = null;

    // lights
    const bulbRing = document.getElementById("bulbRing");
    let bulbCount = 36;

    // ui
    const spinBtn = document.getElementById("spinBtn");
    const overlay = document.getElementById("overlay");
    const closeOverlay = document.getElementById("closeOverlay");
    const spinAgain = document.getElementById("spinAgain");
    const revealMyst = document.getElementById("revealMyst");
    const resultTitle = document.getElementById("resultTitle");
    const resultLabel = document.getElementById("resultLabel");
    const resultValue = document.getElementById("resultValue");
    const resultCard = document.getElementById("resultCard");
    const mystExtra = document.getElementById("mystExtra");

    const soundToggle = document.getElementById("soundToggle");
    const confettiToggle = document.getElementById("confettiToggle");

    // confetti
    const confettiCanvas = document.getElementById("confetti");
    const cfx = confettiCanvas.getContext("2d");
    let confettiPieces = [];
    let confettiRAF = null;

    // ---------- HELPERS ----------
    function loadItems(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return structuredClone(DEFAULT_ITEMS);
        const parsed = JSON.parse(raw);
        if(!Array.isArray(parsed) || parsed.length < 2) return structuredClone(DEFAULT_ITEMS);

        // Ensure there is exactly ONE Mystery Prize.
        let hasMyst = parsed.some(x => x && x.type === "MYSTERY");
        let cleaned = parsed.filter(x => x && typeof x.text === "string" && typeof x.type === "string");
        if(!hasMyst) cleaned.push({ text:"Mystery Prize (Parents decide!)", type:"MYSTERY", weight:1 });

        // If multiple mysteries, keep first
        let seenMyst = false;
        cleaned = cleaned.map(x=>{
          if(x.type === "MYSTERY"){
            if(seenMyst) return null;
            seenMyst = true;
          }
          return { text: x.text.trim() || "Item", type: normalizeType(x.type), weight: 1 };
        }).filter(Boolean);

        return cleaned;
      }catch(e){
        return structuredClone(DEFAULT_ITEMS);
      }
    }

    function saveItems(){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(items));
    }

    function resetItems(){
      items = structuredClone(DEFAULT_ITEMS);
      saveItems();
      renderEditor();
      drawWheel();
    }

    function normalizeType(t){
      const u = String(t || "").toUpperCase();
      if(u === "SKULL") return "SKULL";
      if(u === "MYSTERY") return "MYSTERY";
      return "GOOD";
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    function rand(min,max){ return min + Math.random()*(max-min); }

    // ---------- SOUND (offline: WebAudio beeps) ----------
    let audioCtx = null;
    function beep(freq=440, duration=0.06, type="sine", gain=0.06){
      if(!soundToggle.checked) return;
      try{
        if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        setTimeout(()=>{ o.stop(); }, duration*1000);
      }catch(e){}
    }

    function spinSoundBurst(){
      if(!soundToggle.checked) return;
      // a few quick casino beeps
      beep(660, 0.05, "square", 0.045);
      setTimeout(()=>beep(880, 0.05, "square", 0.045), 60);
      setTimeout(()=>beep(990, 0.05, "square", 0.04), 120);
    }

    function winSound(){
      if(!soundToggle.checked) return;
      beep(523, .08, "triangle", 0.06);
      setTimeout(()=>beep(659, .08, "triangle", 0.06), 90);
      setTimeout(()=>beep(784, .10, "triangle", 0.06), 180);
    }
    function skullSound(){
      if(!soundToggle.checked) return;
      beep(220, .12, "sawtooth", 0.05);
      setTimeout(()=>beep(185, .14, "sawtooth", 0.05), 130);
    }
    function mysterySound(){
      if(!soundToggle.checked) return;
      beep(330, .08, "square", 0.045);
      setTimeout(()=>beep(440, .08, "square", 0.045), 90);
      setTimeout(()=>beep(660, .12, "square", 0.045), 180);
    }

    // ---------- CONFETTI ----------
    function resizeConfetti(){
      confettiCanvas.width = window.innerWidth * devicePixelRatio;
      confettiCanvas.height = window.innerHeight * devicePixelRatio;
    }
    window.addEventListener("resize", resizeConfetti);
    resizeConfetti();

    function launchConfetti(){
      if(!confettiToggle.checked) return;
      confettiPieces = [];
      const count = 220;
      for(let i=0;i<count;i++){
        confettiPieces.push({
          x: rand(0, confettiCanvas.width),
          y: rand(-confettiCanvas.height*0.2, confettiCanvas.height*0.1),
          vx: rand(-1.2, 1.2) * devicePixelRatio,
          vy: rand(1.6, 4.2) * devicePixelRatio,
          r: rand(2, 6) * devicePixelRatio,
          a: rand(0, Math.PI*2),
          va: rand(-0.2, 0.2)
        });
      }
      confettiCanvas.classList.add("show");
      const start = performance.now();
      const dur = 1800;

      function step(now){
        const t = now - start;
        cfx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
        for(const p of confettiPieces){
          p.x += p.vx;
          p.y += p.vy;
          p.a += p.va;
          p.vy += 0.02 * devicePixelRatio;

          // draw (no fixed colors requested; use a simple rotating palette but not set by user)
          cfx.save();
          cfx.translate(p.x, p.y);
          cfx.rotate(p.a);
          cfx.globalAlpha = 0.95;
          cfx.fillStyle = ["#66ffd2","#ffd34d","#ff5bd1","#7ad7ff","#a98bff"][Math.floor(rand(0,5))];
          cfx.fillRect(-p.r, -p.r/2, p.r*2, p.r);
          cfx.restore();
        }
        if(t < dur){
          confettiRAF = requestAnimationFrame(step);
        }else{
          confettiCanvas.classList.remove("show");
          cfx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
          confettiPieces = [];
        }
      }
      cancelAnimationFrame(confettiRAF);
      confettiRAF = requestAnimationFrame(step);
    }

    // ---------- LIGHTS ----------
    function makeBulbs(){
      bulbRing.innerHTML = "";
      const rect = bulbRing.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height);
      const cx = rect.width/2;
      const cy = rect.height/2;
      const radius = size/2 - 10;

      for(let i=0;i<bulbCount;i++){
        const a = (i / bulbCount) * Math.PI*2;
        const x = cx + Math.cos(a) * radius;
        const y = cy + Math.sin(a) * radius;

        const b = document.createElement("div");
        b.className = "bulb" + (i%2 ? " alt" : "");
        b.style.left = x + "px";
        b.style.top = y + "px";
        b.style.background = ["#66ffd2","#ffd34d","#ff5bd1","#7ad7ff","#a98bff"][i%5];
        bulbRing.appendChild(b);
      }
    }

    function setBulbSpeedFast(isFast){
      bulbRing.querySelectorAll(".bulb").forEach((b, idx)=>{
        if(isFast){
          b.classList.add("fast");
          if(idx%2) b.classList.add("alt");
        }else{
          b.classList.remove("fast");
        }
      });
    }

    // call after layout
    requestAnimationFrame(makeBulbs);
    window.addEventListener("resize", ()=>requestAnimationFrame(makeBulbs));

    // ---------- WHEEL DRAW ----------
    const COLOR_GOOD = ["#66ffd2","#ffd34d","#7ad7ff","#a98bff","#ff5bd1","#8cff6b","#ff8a5b","#66b3ff"];
    const COLOR_SKULL = ["#ff4b8a","#b84bff","#ff5b7a","#ff3b68"];
    const COLOR_MYST = ["#ffd34d","#ff5bd1","#7ad7ff","#66ffd2"];

    function drawWheel(){
      // crisp scaling
      const dpr = devicePixelRatio || 1;
      const cssSize = wheelCanvas.getBoundingClientRect().width;
      const px = Math.floor(cssSize * dpr);
      wheelCanvas.width = px;
      wheelCanvas.height = px;

      const w = wheelCanvas.width;
      const h = wheelCanvas.height;
      const cx = w/2, cy = h/2;
      const outerR = w*0.48;
      const innerR = w*0.12;

      ctx.clearRect(0,0,w,h);

      // outer glow ring
      ctx.save();
      ctx.translate(cx,cy);
      ctx.beginPath();
      ctx.arc(0,0, outerR*1.03, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = outerR*0.06;
      ctx.shadowColor = "rgba(0,0,0,.6)";
      ctx.shadowBlur = outerR*0.12;
      ctx.stroke();
      ctx.restore();

      // slices
      const n = items.length;
      const slice = (Math.PI*2)/n;

      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(rotation);

      for(let i=0;i<n;i++){
        const start = i*slice;
        const end = start + slice;

        const it = items[i];
        const type = normalizeType(it.type);
        let fill;
        if(type==="SKULL") fill = COLOR_SKULL[i % COLOR_SKULL.length];
        else if(type==="MYSTERY") fill = COLOR_MYST[i % COLOR_MYST.length];
        else fill = COLOR_GOOD[i % COLOR_GOOD.length];

        // slice
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0,0, outerR, start, end);
        ctx.closePath();
        ctx.fillStyle = fill;
        ctx.fill();

        // slice shading
        ctx.save();
        const grad = ctx.createRadialGradient(0,0, innerR, 0,0, outerR);
        grad.addColorStop(0, "rgba(255,255,255,.18)");
        grad.addColorStop(1, "rgba(0,0,0,.18)");
        ctx.fillStyle = grad;
        ctx.fill();
        ctx.restore();

        // slice borders
        ctx.strokeStyle = "rgba(0,0,0,.22)";
        ctx.lineWidth = outerR*0.012;
        ctx.stroke();

        // text (auto wrap + shrink)
        drawSliceText(ctx, it.text, start + slice/2, innerR, outerR, slice, type);
      }

      // center cap
      ctx.beginPath();
      ctx.arc(0,0, innerR*1.25, 0, Math.PI*2);
      const cap = ctx.createRadialGradient(0,0, innerR*0.2, 0,0, innerR*1.25);
      cap.addColorStop(0, "rgba(255,255,255,.95)");
      cap.addColorStop(0.35, "rgba(255,255,255,.35)");
      cap.addColorStop(1, "rgba(0,0,0,.18)");
      ctx.fillStyle = cap;
      ctx.fill();
      ctx.lineWidth = innerR*0.10;
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.stroke();

      ctx.restore();
    }

    function drawSliceText(ctx, text, midAngle, innerR, outerR, sliceAngle, type){
      // Text region and wrapping heuristics
      const dpr = devicePixelRatio || 1;

      // radius at which we place text
      const r = innerR + (outerR-innerR)*0.62;

      // approximate max width across slice at that radius
      const arcLen = r * sliceAngle;
      const maxWidth = arcLen * 0.78;

      // approximate max height available
      const maxHeight = (outerR - innerR) * 0.36;

      // style
      let baseSize = 24 * dpr;
      let minSize = 12 * dpr;

      // Make skull/myst a bit bolder / slightly smaller
      if(type==="SKULL") baseSize = 22*dpr;
      if(type==="MYSTERY") baseSize = 22*dpr;

      // Try font sizes until it fits
      let fontSize = baseSize;
      let lines = [];
      for(; fontSize >= minSize; fontSize -= 1*dpr){
        ctx.font = `900 ${fontSize}px ui-sans-serif, system-ui, Segoe UI, Arial`;
        lines = wrapLines(ctx, text, maxWidth, 3);
        const lineH = fontSize * 1.06;
        const totalH = lines.length * lineH;
        if(totalH <= maxHeight) break;
      }

      ctx.save();
      ctx.rotate(midAngle);
      ctx.translate(r, 0);
      ctx.rotate(Math.PI/2); // make text roughly upright along radial direction

      // shadow for readability
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      const lineH = fontSize * 1.06;
      const totalH = lines.length * lineH;
      const startY = -totalH/2 + lineH/2;

      // draw shadow + text
      for(let i=0;i<lines.length;i++){
        const y = startY + i*lineH;
        ctx.fillText(lines[i], 1.6, y + 1.6);
      }

      // main text
      ctx.fillStyle = "rgba(10,10,20,.92)";
      if(type==="SKULL") ctx.fillStyle = "rgba(20,10,20,.92)";
      if(type==="MYSTERY") ctx.fillStyle = "rgba(15,10,20,.92)";
      for(let i=0;i<lines.length;i++){
        const y = startY + i*lineH;
        ctx.fillText(lines[i], 0, y);
      }

      ctx.restore();
    }

    function wrapLines(ctx, text, maxWidth, maxLines){
      const words = String(text || "").trim().split(/\s+/).filter(Boolean);
      if(words.length === 0) return ["‚Äî"];

      const lines = [];
      let line = words[0];

      for(let i=1;i<words.length;i++){
        const test = line + " " + words[i];
        if(ctx.measureText(test).width <= maxWidth){
          line = test;
        }else{
          lines.push(line);
          line = words[i];
          if(lines.length === maxLines-1) break;
        }
      }

      // Remaining words
      const remaining = words.slice(lines.join(" ").split(/\s+/).filter(Boolean).length);
      if(lines.length < maxLines){
        // rebuild last line from remaining
        let last = remaining[0] || line;
        for(let i=1;i<remaining.length;i++){
          const test = last + " " + remaining[i];
          if(ctx.measureText(test).width <= maxWidth){
            last = test;
          }else{
            // if still too long, we'll truncate with ellipsis
            while(last.length > 3 && ctx.measureText(last + "‚Ä¶").width > maxWidth){
              last = last.slice(0,-1);
            }
            last = last + "‚Ä¶";
            lines.push(last);
            return lines;
          }
        }
        lines.push(last);
      }

      // ensure at least 1
      return lines.slice(0, maxLines);
    }

    // ---------- PICK WINNER ----------
    function chooseIndexWeighted(forceType=null){
      // weights are all 1 now, but we keep it ready
      const pool = items.map((it, idx)=>({idx, w: Math.max(0.0001, it.weight || 1), type: normalizeType(it.type)}));

      let candidates = pool;
      if(forceType){
        candidates = pool.filter(p => p.type === forceType);
        if(candidates.length === 0) candidates = pool;
      }

      const total = candidates.reduce((s,p)=>s+p.w,0);
      let r = Math.random() * total;
      for(const p of candidates){
        r -= p.w;
        if(r <= 0) return p.idx;
      }
      return candidates[candidates.length-1].idx;
    }

    function indexAtPointer(finalRotation){
      // Pointer is at top (angle -PI/2 in canvas coords). We rotated wheel by rotation.
      // We want which slice ends up under the pointer.
      const n = items.length;
      const slice = (Math.PI*2)/n;

      // Convert pointer angle in wheel's local coords
      // pointer angle in world = -PI/2. wheel rotation rotates slices.
      // local angle = (-PI/2 - rotation) normalized to [0,2pi)
      let ang = (-Math.PI/2 - finalRotation) % (Math.PI*2);
      if(ang < 0) ang += Math.PI*2;

      const idx = Math.floor(ang / slice);
      return clamp(idx, 0, n-1);
    }

    // ---------- SPIN ----------
    function spin(forceType=null){
      if(spinning) return;
      if(items.length < 2) return;

      spinning = true;
      spinBtn.disabled = true;
      setBulbSpeedFast(true);
      spinSoundBurst();

      const targetIndex = chooseIndexWeighted(forceType);

      // We want wheel to stop so that targetIndex lands at pointer
      // Choose a big extra rotation for drama
      const n = items.length;
      const slice = (Math.PI*2)/n;

      // target slice center angle in wheel local coordinates:
      const targetCenter = targetIndex*slice + slice/2;

      // Need finalRotation such that pointer local angle lands in that slice:
      // local angle at pointer = (-PI/2 - finalRotation) => should equal targetCenter
      // so finalRotation = -PI/2 - targetCenter
      let baseFinal = -Math.PI/2 - targetCenter;

      // add extra full spins (casino!)
      const extraSpins = 6 + Math.floor(Math.random()*4); // 6..9
      const finalRotation = baseFinal + extraSpins * Math.PI*2;

      const startRotation = rotation;
      const delta = finalRotation - startRotation;

      const duration = 4200 + Math.random()*900; // ms
      const start = performance.now();

      // tick clicks
      let lastTick = -1;

      function frame(now){
        const t = clamp((now - start)/duration, 0, 1);
        const eased = easeOutCubic(t);
        rotation = startRotation + delta * eased;

        // tick sound when crossing slice boundaries
        const currentIdx = indexAtPointer(rotation);
        if(currentIdx !== lastTick){
          lastTick = currentIdx;
          beep(1200, 0.02, "square", 0.02);
        }

        drawWheel();

        if(t < 1){
          spinRAF = requestAnimationFrame(frame);
        }else{
          spinning = false;
          spinBtn.disabled = false;
          setBulbSpeedFast(false);

          const winnerIdx = indexAtPointer(rotation);
          showResult(winnerIdx);
        }
      }

      cancelAnimationFrame(spinRAF);
      spinRAF = requestAnimationFrame(frame);
    }

    // ---------- RESULT UI ----------
    let lastWinnerIdx = null;
    function showResult(idx){
      lastWinnerIdx = idx;
      const it = items[idx];
      const type = normalizeType(it.type);

      overlay.classList.add("show");
      mystExtra.style.display = "none";
      revealMyst.style.display = "none";

      resultCard.classList.remove("good","skull","myst");
      if(type==="SKULL"){
        resultTitle.textContent = "Uh oh‚Ä¶ üíÄ";
        resultLabel.textContent = "TASK TIME";
        resultValue.textContent = it.text.replace(/^SKULL:\s*/i, "");
        resultCard.classList.add("skull");
        skullSound();
      }else if(type==="MYSTERY"){
        resultTitle.textContent = "Mystery Prize! ‚ùì";
        resultLabel.textContent = "YOU GOT";
        resultValue.textContent = "Mystery Prize";
        resultCard.classList.add("myst");
        mystExtra.style.display = "block";
        revealMyst.style.display = "inline-flex";
        mysterySound();
        launchConfetti();
      }else{
        resultTitle.textContent = "Winner! üéâ";
        resultLabel.textContent = "YOU WON";
        resultValue.textContent = it.text;
        resultCard.classList.add("good");
        winSound();
        launchConfetti();
      }
    }

    closeOverlay.addEventListener("click", ()=>overlay.classList.remove("show"));
    overlay.addEventListener("click", (e)=>{ if(e.target === overlay) overlay.classList.remove("show"); });

    spinAgain.addEventListener("click", ()=>{
      overlay.classList.remove("show");
      setTimeout(()=>spin(null), 120);
    });

    revealMyst.addEventListener("click", ()=>{
      // Parents can decide the real prize; this is a ‚Äúreveal‚Äù moment
      resultValue.textContent = "Ask a parent to reveal it! üòÑ";
      beep(880, .08, "triangle", 0.06);
      setTimeout(()=>beep(988, .10, "triangle", 0.06), 90);
      setTimeout(()=>beep(1175, .12, "triangle", 0.06), 190);
    });

    // ---------- EDITOR ----------
    const itemsEl = document.getElementById("items");
    const addItemBtn = document.getElementById("addItem");
    const saveWheelBtn = document.getElementById("saveWheel");
    const resetWheelBtn = document.getElementById("resetWheel");

    function renderEditor(){
      itemsEl.innerHTML = "";
      items.forEach((it, idx)=>{
        const row = document.createElement("div");
        row.className = "row";

        const input = document.createElement("input");
        input.type = "text";
        input.value = it.text;
        input.placeholder = "Item text";
        input.addEventListener("input", ()=>{
          items[idx].text = input.value;
        });

        const tag = document.createElement("button");
        tag.className = "tagBtn";
        const t = normalizeType(it.type);
        setTagStyle(tag, t);

        tag.addEventListener("click", ()=>{
          // Mystery is fixed type
          const cur = normalizeType(items[idx].type);
          if(cur === "MYSTERY"){
            // keep mystery mystery
            beep(620, 0.04, "square", 0.03);
            return;
          }
          const next = cur === "GOOD" ? "SKULL" : "GOOD";
          items[idx].type = next;
          setTagStyle(tag, next);
          beep(next==="SKULL" ? 240 : 880, 0.04, "square", 0.03);
        });

        const del = document.createElement("button");
        del.className = "delBtn";
        del.textContent = "‚úï";

        const isMyst = normalizeType(it.type) === "MYSTERY";
        if(isMyst){
          del.disabled = true;
          del.title = "Mystery Prize can‚Äôt be deleted (parents decide!)";
        }else{
          del.addEventListener("click", ()=>{
            items.splice(idx, 1);
            // always keep a mystery item
            if(!items.some(x => normalizeType(x.type)==="MYSTERY")){
              items.push({ text:"Mystery Prize (Parents decide!)", type:"MYSTERY", weight:1 });
            }
            saveItems();
            renderEditor();
            drawWheel();
            beep(380, 0.04, "square", 0.03);
          });
        }

        row.appendChild(input);
        row.appendChild(tag);
        row.appendChild(del);
        itemsEl.appendChild(row);
      });
    }

    function setTagStyle(btn, type){
      btn.classList.remove("tagGood","tagSkull","tagMyst");
      if(type==="SKULL"){
        btn.textContent = "üíÄ SKULL";
        btn.classList.add("tagSkull");
      }else if(type==="MYSTERY"){
        btn.textContent = "‚ùì MYSTERY";
        btn.classList.add("tagMyst");
      }else{
        btn.textContent = "üéÅ GOOD";
        btn.classList.add("tagGood");
      }
    }

    addItemBtn.addEventListener("click", ()=>{
      items.unshift({ text: "New reward!", type: "GOOD", weight: 1 });
      saveItems();
      renderEditor();
      drawWheel();
      beep(990, 0.05, "square", 0.03);
    });

    saveWheelBtn.addEventListener("click", ()=>{
      // Clean up + ensure one mystery exists
      items = items.map(x => ({
        text: String(x.text || "Item").trim() || "Item",
        type: normalizeType(x.type),
        weight: 1
      }));

      if(!items.some(x => x.type==="MYSTERY")){
        items.push({ text:"Mystery Prize (Parents decide!)", type:"MYSTERY", weight:1 });
      }else{
        // keep first mystery only
        let seen = false;
        items = items.filter(x=>{
          if(x.type==="MYSTERY"){
            if(seen) return false;
            seen = true;
          }
          return true;
        });
      }

      saveItems();
      renderEditor();
      drawWheel();
      beep(880, 0.06, "triangle", 0.06);
      setTimeout(()=>beep(988, 0.06, "triangle", 0.06), 90);
    });

    resetWheelBtn.addEventListener("click", resetItems);

    // ---------- BUTTONS ----------
    spinBtn.addEventListener("click", ()=>spin(null));
    document.getElementById("testWin").addEventListener("click", ()=>spin("GOOD"));
    document.getElementById("testSkull").addEventListener("click", ()=>spin("SKULL"));
    document.getElementById("testMyst").addEventListener("click", ()=>spin("MYSTERY"));

    // ---------- INIT ----------
    renderEditor();
    drawWheel();

  </script>
</body>
</html>
